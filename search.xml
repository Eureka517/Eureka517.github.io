<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++前缀和/差分</title>
      <link href="/2023/04/20/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2023/04/20/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和-差分"><a href="#前缀和-差分" class="headerlink" title="前缀和/差分"></a>前缀和/差分</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>一维前缀和的作用：快速求出元素组中某段区间的和</p><ol><li>思路<ol><li>原数组: a[1], a[2], a[3], a[4], a[5], …, a[n]</li><li>前缀和：Si为数组的前i项和 <code>S[i] = a[1] + a[2] + a[3] + … + a[i]</code></li><li>求[l, r]中的和, 即为<code>S[r] - S[l-1]</code></li></ol></li></ol><ul><li>S[0]应当设置为0来应对l=1的情况</li></ul><ol><li>模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],S[N]; <span class="comment">//全局变量默认为0，此时S[0]=0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) S[i]=S[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; S[r]-S[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>二维前缀和的作用：快速求出某子矩阵元素的和</p><ol><li><p>思路</p><ol><li>原数组：a[i][j]</li><li>前缀和：S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]</li><li>(x1,y1)和(x2,y2)之间的子矩阵中的所有数之和 = S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]</li></ol></li><li><p>模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            s[i][j] = s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]; <span class="comment">// 求前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        cout &lt;&lt; S[x2][y2] - S[x1<span class="number">-1</span>][y2] - S[x2][y1<span class="number">-1</span>] + S[x1<span class="number">-1</span>][y1<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>一维差分的作用：使元素组中某段区间中每个元素加上c</p><ol><li>思路<ol><li>原数组: a[1], a[2], a[3], a[4], a[5], …, a[n]</li><li>差分数组：b[i] = a[i] - a[i-1]</li></ol><ul><li>a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。此时a[i] = b[1]+b[2]+……+b[i]</li></ul><ol start="3"><li>给数组a区间[l,r]中的每个数加上c:b[l]+=c,b[r+1]-=c</li></ol><ul><li><code>b[l]+c</code>，效果使得a数组中a[l]及以后的数都加上了c，但我们只要求l到r区间加上c, 因此还需要执行<code>b[r+1]-c</code>,让a数组中a[r+1]及往后的区间再减去c，这样对于a[r]以后区间的数相当于没有发生改变。<br>一维差分结论：给a数组中的[ l, r]区间中的每一个数都加上c,只需对差分数组b做 <code>b[l] + = c, b[r+1] - = c</code>。时间复杂度为O(1), 大大提高了效率。</li></ul><ol start="4"><li>根据改动后的b数组重新通过前缀和求得a[i] = a[i-1] + b[i]</li></ol></li><li>模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//计算差分数组b</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) <span class="comment">//进行差分操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        b[l] += c;</span><br><span class="line">        b[r+<span class="number">1</span>] -= c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//根据b数组重新得到a数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] + b[i];</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>二维差分的作用：使子矩阵中每个元素加上c</p><ol><li><p>思路</p><ol><li>原数组：a[i][j]</li><li>差分数组：b[i][j]<br>使得a数组中a[i][j]是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。</li><li>(x1,y1)和(x2,y2)之间的子矩阵中的所有数：<br> b[x1][y1]+=c ; (x1,y1)右下部分矩阵+c<br> b[x1][y2+1]-=c ; (x1,y2+1)右下部分矩阵-c<br> b[x2+1][y1]-=c ; (x2+1,y1)右下部分矩阵-c<br> b[x2+1][y2+1]+=c; (x2+1,y2+1)右下部分矩阵+c</li></ol><ul><li>原则：a数组是b数组的前缀和数组，对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往右往下的每一个数。</li></ul><ol start="4"><li>根据改动后的b数组重新通过前缀和求得a[i][j] = a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j]</li></ol></li><li><p>模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//计算差分数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            b[i][j]=a[i][j]-a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j]+a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--) <span class="comment">//差分过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,x2,y1,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        b[x1][y1] +=c;</span><br><span class="line">        b[x2+<span class="number">1</span>][y1] -=c;</span><br><span class="line">        b[x1][y2+<span class="number">1</span>] -=c;</span><br><span class="line">        b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] +=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//根据b数组重新得到a数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i][j];</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++归并排序算法</title>
      <link href="/2023/04/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序-merge-sort"><a href="#归并排序-merge-sort" class="headerlink" title="归并排序(merge_sort)"></a>归并排序(merge_sort)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>确定位置分界点：mid=(l+r)/2，平分为两段</li><li>递归排列left和right,递归到最后达成只有一个数的数组，此时认定是有序的</li><li>归并(合二为一)：使用一个数组来存放合并两段的结果。2个指针分别从两段开始出发，比较大小，小的放入数组，并将指针后移，使得两段按照次序组合在一起。如果2个指针对应的数一样大先将第一段的值放入。</li></ol><ul><li>和快排的区别：快排的分界点为q[l+r&gt;&gt;1]，数组元素根据数值大小分布在两侧；归并排序的分界点为<code>l+r&gt;&gt;1</code>，按照数组排列顺序分布两段</li></ul><hr><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 递归边界条件(此时的区间如果只有一个数或者没有数，则不需要排序)</span></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 确定分界点中点</span></span><br><span class="line"><span class="built_in">merge_sort</span>(q, l, mid); <span class="comment">// 递归操作左边</span></span><br><span class="line"><span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r); <span class="comment">// 递归操作右边</span></span><br><span class="line">  <span class="comment">//归并</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])tmp[k++] = q[i++]; <span class="comment">//使用&lt;=进行判定，确保排序的稳定性</span></span><br><span class="line"><span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++]; <span class="comment">// 这两条while有且只有一条会执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = l, k = <span class="number">0</span>; i &lt;= r; i++, k++)q[i] = tmp[k]; <span class="comment">// 将临时数组tem的值赋回到q中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="边界分析"><a href="#边界分析" class="headerlink" title="边界分析"></a>边界分析</h3><ol><li>mid分界<br>为什么不用 mid - 1 作为分隔线呢？</li></ol><p>即 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r)</p><p>因为 mid = l + r &gt;&gt; 1 是向下取整，mid 有可能取到 l (数组只有两个数时)，造成无限划分</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++快速排序算法</title>
      <link href="/2023/04/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序-quick-sort"><a href="#快速排序-quick-sort" class="headerlink" title="快速排序(quick_sort)"></a>快速排序(quick_sort)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>确认数值分界点：一般选取q[(l+r)/2]作为分界的数值，不要取q[l]和q[r]会产生边界问题。</li><li>调整区间：双指针分别从左右开始向中间，直到指针相遇。使得相遇点左边的值全都&lt;=q[(l+r)/2],右边的值全都&gt;=q[(l+r)/2]。中间过程中遇到不满足的值则指针停止，两侧指针停止则交换两个指针的值，然后指针继续向中间靠拢。</li><li>递归处理左右两边</li></ol><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//注释为分界为i的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">//递归的边界条件(此时考虑的区间没有数或是只有一个数，则不用进行排序)</span></span><br><span class="line"><span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//int x=q[l+r+1&gt;&gt;1]一定要确保向上取整</span></span><br><span class="line"><span class="comment">//i和j设置在端点两侧是因为下面的操作是先移动在判断</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)<span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//quick_sort(q, l, i-1);</span></span><br><span class="line"><span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);<span class="comment">//quick_sort(q, i, r);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="使用do-while-强制对于i和j进行移动"><a href="#使用do-while-强制对于i和j进行移动" class="headerlink" title="使用do-while(强制对于i和j进行移动)"></a>使用do-while(强制对于i和j进行移动)</h3><p>注意:由于使用do-while循环,所以i和j一定会自增,使得循环会继续下去,但是如果采用while循环(i和j的初始化做出对应的变更),i和j在特殊情况下不自增的话,循环就会卡死</p><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q[i] &lt; x) i++;</span><br><span class="line"><span class="keyword">while</span>(q[j] &gt; x) j--;</span><br><span class="line"><span class="comment">//当q[i]和q[j]都为 x 时, i 和 j 都不会更新,导致 while 陷入死循环</span></span><br></pre></td></tr></table></figure><h3 id="边界情况分析"><a href="#边界情况分析" class="headerlink" title="边界情况分析"></a>边界情况分析</h3><p>   快排属于分治算法，最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分(不能使得递归分割成的区间存在空区间)</p><ol><li><p>x取值的选择和使用i/j进行递归的关系</p><ul><li>以j为划分时，x不能选q[r]；若以i为划分,则x不能选q[l]<br>因为j的取值为[l,r-1]<br>以j为例，当若x选为q[r]，数组中q[l..r-1] &lt; x。那么这一轮循环结束时i = r, j = r，显然会造成无限划分</li></ul></li><li><p>while中判定条件严格大小写</p><ul><li>do i++; while(q[i] &lt; x)和do j–; while(q[j] &gt; x) 中不能用q[i] &lt;= x 和 q[j] &gt;= x</li></ul><p> 例如：<br> 假设q[l..r]全相等<br> 则执行完do i++; while(q[i] &lt;= x);之后，i会自增到r+1.然后继续执行q[i] &lt;= x 判断条件，造成数组下标越界(但这貌似不会报错).并且如果之后的q[i] &lt;= x (此时i &gt; r) 条件也不幸成立，就会造成一直循环下去。</p></li><li><p>if(i &lt; j) swap(q[i], q[j])可以使用i &lt;= j<br> 可以使用if(i &lt;= j) swap(q[i], q[j]);<br> 因为 i = j 时，交换一下q[i],q[j] 无影响，因为马上就会跳出循环了</p></li><li><p>不能改用quick_sort(q, l, j-1), quick_sort(q, j, r)作为划分<br>此时 q[l..i-1] &lt;= x, q[i] &gt;= x</p><pre><code> q[j+1..r] &gt;= x, q[j] &lt;= x i &gt;= j</code></pre><p> 所以，q[l..j-1] &lt;= x 是显然成立的，应当使用j和j+1来分界</p></li><li><p>while(i &lt; j) 不能改为 while(i &lt;= j)<br> 可能会导致无限划分</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++二分算法</title>
      <link href="/2023/04/20/%E4%BA%8C%E5%88%86/"/>
      <url>/2023/04/20/%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><h2 id="思路-有序列中找分界点"><a href="#思路-有序列中找分界点" class="headerlink" title="思路(有序列中找分界点)"></a>思路(有序列中找分界点)</h2><p>以n个数中需要找到第一个<code>&lt;m</code>的数为例</p><ol><li>双指针算法<br>双指针算法的两个指针从<code>l=-1</code>和<code>r=n</code>出发，一步步向中间移动直到<code>l+1=r</code>并找到分界点(按照需求选取l/r)。在移动的过程中<code>[0,l]</code>和<code>[r,n-1]</code>两个区间总是分别满足<code>&lt;m</code>和<code>&gt;=m</code>。而<code>[l,r]</code>中的元素的性质则不明确，双指针移动的过程就是在确定其中元素的性质。</li><li>二分查找<br>二分查找建立在双指针算法的基础之上。二分查找通过判断<code>[l,r]</code>的<code>mid=l+r&gt;&gt;1</code>是否满足性质来加速指针移动的过程,直到<code>l+1=r</code></li></ol><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> L=<span class="number">-1</span>,R=n;</span><br><span class="line"><span class="keyword">while</span>(L+<span class="number">1</span>!=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>()) L=mid;</span><br><span class="line"><span class="keyword">else</span> R=mid;</span><br><span class="line"><span class="comment">//最后根据你所分左右两边区间的结果</span></span><br><span class="line"><span class="comment">//选取L或者R作为结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>L的初始值为-1，R的初始值为n<br>首先，如果二分本来就没有结果。比如对于本文例题 1 2 2 3 3 4，如果你要寻找第一个&gt;=5的数，你会发现，整个过程都在执行L=mid，最后得到的结果中,R是等于下标6的，他明显这个时候是越界的，说明我们找不到要寻找的数字，而如果我们一开始将R赋值为n-1，也就是赋值为下标5的时候，他返回的R是5，是没有越界的，被我们当成了答案，但其实这时候我们的二分是没有答案的,就发生了错误；其次，L最小值为-1，R最小值只能取到1，因为<code>L+1！=R</code>为循环结束条件，R最大值为n,同理则L的最大值为n-2，则（L+R）/2的取值范围是<code>[0,n)</code>，mid的值始终位于0到n的左闭右开区间里面,不会发生越界的错误；</li><li>循环结束的条件是<code>while(L+1!=R)</code><br>之前学的二分，循环结束的条件是<code>while(L&lt;R)</code>。而这边给出的循环条件是<code>while(L+1!=R)</code> 其实，就是当L和R相邻的时候，循环就结束，而原本的<code>while(L&lt;R)</code>是当两区间重合以后，循环才结束，所以之前我们需要判断对mid进行加一或者减一的操作，而且因为区间重合的问题，最后返回的L、R还要再进行判断，而这边的这个二分，因为区间反回的是不重合的两区间，只有L=mid和R=mid这两种情况，最后根据需要返回L或者R；</li><li>不会陷入死循环<br>对于比较奇葩的情况，比如数组大小为1或者2,int a[1],b[2];由于我们是while(L+1!=R)结束循环，也就是当L和R相邻的时候结束条件<br>对于a[1],他的下标为0 此时L=-1，R=n也就是1<br>对于b[2],他的下标为0,1 此时L=-1，R=n也就是2<br>所以无论何种情况，初始的L+1始终小于R，历经循环后最终L和R相邻，不会出现一开始L就和R重合等情况导致出现while(L+1!=R)循环不能结束的情况</li></ol><hr><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分缩小区间，因为是小数，最后不能以<code>L+1！=R</code>作为循环结束条件，判定条件为<code>r-l &lt; 1e-x</code>(x为题目要求精度+2)，即两者差距小于一定值是认定L和R相邻</p><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;<span class="comment">//理解为在-10000~10000的范围内找到需要的数</span></span><br><span class="line"><span class="keyword">while</span>(r-l&gt;=<span class="number">1e-8</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="type">double</span> mid = (l + r)/<span class="number">2</span>;<span class="comment">//此时无需考虑+1的问题</span></span><br><span class="line"><span class="keyword">if</span> (mid * mid * mid &gt;= x)r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, r);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++基本语法</title>
      <link href="/2023/04/20/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/20/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="易错知识点"><a href="#易错知识点" class="headerlink" title="易错知识点"></a>易错知识点</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><table><thead><tr><th>类型</th><th>取值</th><th>大小</th><th>注释</th></tr></thead><tbody><tr><td>bool</td><td>false/true</td><td>1 byte</td><td></td></tr><tr><td>char</td><td>‘a’、’c’</td><td>1 byte</td><td></td></tr><tr><td>int</td><td>-2147483648～+2147483647</td><td>4 byte</td><td>int的最大值是个以二开头的十位数</td></tr><tr><td>long long [int]</td><td>-9223372036854775808 ～+9223372036854775807</td><td>8 byte</td><td>long long的最大值是一个以9开头的十九位的数</td></tr><tr><td>float</td><td>1.23 2.63</td><td>4 byte</td><td>6-7位有效数字</td></tr><tr><td>double</td><td>3.123456789123</td><td>8 byte</td><td>15-16位有效数字</td></tr><tr><td>long double</td><td></td><td>12byte</td><td>18-19位有效数，很少用到</td></tr></tbody></table><ul><li>写算法99%的情况会用double不用float，因为float精度6-7位,double精度15-16位,位数有300多位，有些LL相乘，也可以用double。</li><li>c++中 double也可 自增，如1.2 自增 变为2.2</li></ul><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ol><li><p>对比</p><ol><li>遇到空格<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d%d %c&quot;,&amp;a,&amp;b,&amp;c);  //%d 后加个空格,防止把空格当字符读入</span><br><span class="line">  * 不过滤空格，要防止把空格作为字符输入</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;         //cin会自动过滤空格</span><br></pre></td></tr></table></figure></li><li>输入字符串中的数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//输入A = 2 , B = 3 要求读入A和B的值</span><br><span class="line">scanf(&quot;A = %d , B = %d&quot;,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>对应的占位符<br>  int         : %d<br>  float       : %f<br>  double      : %lf<br>  char        : %c<br>  long long   : %lld</p></li><li><p>规定位数<br>  printf(“%.3lf”,a); //输出a的三位小数</p></li><li><p>输出对齐<br>  printf(“%5d”,a); //a占5个字符，在左侧加空格<br>  printf(“%-5d”,a); //a占5个字符，在右侧加空格<br>  printf(“%05d”,a); //a占5个字符，在左侧加0<br>  printf(“%5.3lf”,a); //a为三位小数，占5个字符，在左侧加空格</p></li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li><p>C++中取模结果正负只与%前面的数的正负有关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; 5%2 &lt;&lt; endl;   输出  1</span><br><span class="line">cout &lt;&lt; 5%-2 &lt;&lt; endl;  输出  1</span><br><span class="line">cout &lt;&lt; -5%2 &lt;&lt; endl;  输出 -1</span><br><span class="line">cout &lt;&lt; -5%-2 &lt;&lt; endl; 输出 -1</span><br></pre></td></tr></table></figure></li><li><p>C++中除法是向0取整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; 5/2 &lt;&lt; endl;    输出  2</span><br><span class="line">cout &lt;&lt; -5/2 &lt;&lt; endl;   输出 -2</span><br></pre></td></tr></table></figure></li><li><p>C++中强制类型转换是向0取整 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (int)2.5 &lt;&lt; endl;  输出  2</span><br><span class="line">cout &lt;&lt; (int)-2.5 &lt;&lt; endl; 输出 -2</span><br></pre></td></tr></table></figure></li></ol><h2 id="while循环条件中输入"><a href="#while循环条件中输入" class="headerlink" title="while循环条件中输入"></a>while循环条件中输入</h2><p>   读入的个数未知时，可以用<code>while(cin &gt;&gt; x)</code>或<code>while(scanf(&quot;%d&quot;, &amp;x) != -1)</code>或<code>while(~scanf(&quot;%d&quot;, &amp;x))</code>来输入。<br>   如果输入的最后一个为0且该0不处理，输入语句可以用<code>while(cin &gt;&gt; x &amp;&amp; x)</code>或while<code>(cin &gt;&gt; x, x)</code>，逗号表达式取最后一个值。</p><h2 id="数组定义位置"><a href="#数组定义位置" class="headerlink" title="数组定义位置"></a>数组定义位置</h2><ol><li>定义在函数内和函数外区别<ol><li>未初始化的数值<br>函数中的数组未经初始化元素数值随机；函数外的数值默认都为0</li><li>数组元素上限<br>函数中的数组存放在栈中，存在元素个数限制；函数外的存放在堆中，不存在元素个数限制<br>注：尽量在函数外定义全局数组</li></ol></li></ol><h2 id="浮点数相等判定"><a href="#浮点数相等判定" class="headerlink" title="浮点数相等判定"></a>浮点数相等判定</h2><p>   由于精度限制，c+中存放的浮点数不是精确数值，浮点数在经过等价运算后会存在微小变化。引入容忍误差，两数在容忍误差内，则认为两数相等。<code>|x-y|&lt;1e-6</code></p><h2 id="字符串和字符数组-C风格字符串-的区别"><a href="#字符串和字符数组-C风格字符串-的区别" class="headerlink" title="字符串和字符数组(C风格字符串)的区别"></a>字符串和字符数组(C风格字符串)的区别</h2><p>   字符串 = 字符数组 + ‘\0’<br>   可以使用字符串来初始化字符数组。但是此时字符串结尾会暗含一个’\0’，因此字符数组至少要比字符串的长度多1<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;;            // 列表初始化，没有空字符</span><br><span class="line">char a2[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;, &#x27;\0&#x27;&#125;;      // 列表初始化，含有显示的空字符</span><br><span class="line">char a3[] = &quot;C++&quot;;                      // 自动添加表示字符串结尾的空字符</span><br><span class="line">char a4[6] = &quot;Daniel&quot;;                  // 错误：没有空间可以存放空字符</span><br></pre></td></tr></table></figure></p><ul><li>可以使用字符数组的时候都可以用字符串</li></ul><h2 id="字符数组的输入输出"><a href="#字符数组的输入输出" class="headerlink" title="字符数组的输入输出"></a>字符数组的输入输出</h2><ol><li>使用cin/cout输入输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">cin &gt;&gt; str;             // 输入字符串时，遇到空格或者回车就会停止。此处不需要循环输入，直接输入即可。</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;    // 输出字符串时，遇到空格或者回车不会停止，遇到&#x27;\0&#x27;时停止</span><br></pre></td></tr></table></figure></li><li>使用fgets进行输入(用于读入一行字符串，包括空格)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">fgets(str, 100, stdin);  // gets函数在新版C++中被移除了，因为不安全。可以用fgets代替，但注意fgets不会删除行末的回车字符</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串string的输入输出"><a href="#字符串string的输入输出" class="headerlink" title="字符串string的输入输出"></a>字符串string的输入输出</h2><ol><li>使用cin/cout输入输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>注：不能用printf直接输出string，需要写成：printf(“%s”, s.c_str())</li><li>使用getline读取一整行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">getline(cin, s);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol><h2 id="string的加法"><a href="#string的加法" class="headerlink" title="string的加法"></a>string的加法</h2><ol><li>两个string对象相加<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello,  &quot;</span><span class="string">&quot;, s2 = &quot;</span>world\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">string s3 = s1 + s2;                    // s3的内容是 hello, world\n</span></span><br><span class="line"><span class="string">s1 += s2;                               // s1 = s1 + s2</span></span><br></pre></td></tr></table></figure></li><li>字面值和string对象相加<br>做加法运算时，字面值和字符都会被转化成string对象，因此直接相加就是将这些字面值串联起来：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;      <span class="comment">// 在s1和s2中都没有标点符号</span></span><br><span class="line">string s3 = s1 + <span class="string">&quot;, &quot;</span> + s2 + <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>字面值不能与字面值相加<br>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span>;  <span class="comment">// 正确：把一个string对象和有一个字面值相加</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>; <span class="comment">// 错误：两个运算对象都不是string</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;  <span class="comment">// 正确，每个加法运算都有一个运算符是string</span></span><br><span class="line">string s7 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span> + s2;  <span class="comment">// 错误：不能把字面值直接相加，运算是从左到右进行的</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h2><ol><li>将string对象当成字符数组来处理<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">     cout &lt;&lt; s[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li>使用基于范围的for语句<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c: s) cout &lt;&lt; c &lt;&lt; endl; <span class="comment">//依次将s中字符赋值给c</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span>&amp; c: s) c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//依次将s中字符的地址传给c</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> x=<span class="number">0</span>; <span class="comment">//只有在第一次被调用的时候会就行初始化，后续再次调用会跳过初始化语句，多用于函数中</span></span><br><span class="line">   x++;</span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相当于在函数内部创建了一个只有该函数能够调用的全局变量</li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ol><li><p>传值参数<br>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">f</span>(x);</span><br><span class="line">   cout &lt;&lt; x &lt;&lt; endl; <span class="comment">//输出10，函数中的改动不影响x的值</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传引用参数<br>当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      x = <span class="number">5</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">      <span class="built_in">f</span>(x);</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; endl; <span class="comment">//输出5，函数中的改动会影响x的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ```  </span><br><span class="line">   * 引用可以实现返回多个参数</span><br><span class="line"></span><br><span class="line">## 数组形参</span><br><span class="line">在函数中对数组中的值的修改，会影响函数外面的数组</span><br><span class="line"><span class="number">1.</span> 一维数组形参的写法</span><br></pre></td></tr></table></figure><p>// 尽管形式不同，但这三个print函数是等价的<br>void print(int <em>a) {/</em> … <em>/}<br>void print(int a[]) {/</em> … <em>/}<br>void print(int a[10]) {/</em> … */}</p><p>print(a) //调用时使用a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 多维数组形参的写法</span><br></pre></td></tr></table></figure><p>// 多维数组中，除了第一维之外，其余维度的大小必须指定<br>void print(int (<em>a)[10]) {/</em> … <em>/}<br>void print(int a[][10]) {/</em> … */}</p><p>print(a) //调用时使用a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 函数递归</span><br><span class="line">在一个函数内部，也可以调用函数本身</span><br><span class="line">```cpp</span><br><span class="line">int fact(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n &lt;= 1) return 1; //递归边界</span><br><span class="line">    else return n * fact(n - 1); //递归过程</span><br><span class="line">    // else还是需要的，因为并不一定涵括所有情况</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fact(n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>递归搜索树</li></ul><h2 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h2><ol><li>类的定义<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age, height;</span><br><span class="line">        <span class="type">double</span> money;</span><br><span class="line">        string books[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_money</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            money += x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; <span class="comment">//注：不同于函数，需要在最后加上分号</span></span><br></pre></td></tr></table></figure>类中的变量和函数被统一称为类的成员变量。</li></ol><ul><li><code>private</code>后面的内容是私有成员变量，在类的外部不能访问；<code>public</code>后面的内容是公有成员变量，在类的外部可以访问。</li></ul><ol start="2"><li><p>类的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;<span class="comment">/* … */</span>&#125; person_a, person_b, persons[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></li><li><p>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;<span class="comment">/* … */</span>&#125; person_a, person_b, persons[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></li></ol><ul><li>结构体和类的作用是一样的。不同点在于类默认是private，结构体默认是public<br>(如果变量和函数比较少且简单，则使用结构体；反之使用函数)</li></ul><h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><ol><li>指针<br>指针指向存放变量的值的地址。因此我们可以通过指针来修改变量的值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">*p += <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li>引用<br>引用和指针类似，相当于给变量起了个别名。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;p = a;</span><br><span class="line"></span><br><span class="line">p += <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>新建链表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> <span class="comment">//建立节点结构体</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> val;</span><br><span class="line">   Node *next;</span><br><span class="line">   <span class="built_in">Node</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val) , <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node a = <span class="built_in">Node</span>(<span class="number">1</span>); <span class="comment">// Node类型变量</span></span><br><span class="line">Node *p = &amp;a; <span class="comment">// 节点使用指针来表示</span></span><br><span class="line"></span><br><span class="line">Node *p =<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>); <span class="comment">//等同于上面两行代码，new返回的是地址</span></span><br></pre></td></tr></table></figure><ul><li>对象和指针访问结构体中元素或函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.next,a.val; <span class="comment">//对象使用.来访问</span></span><br><span class="line">p -&gt; val; <span class="comment">//指针使用-&gt;来访问</span></span><br></pre></td></tr></table></figure></li></ul></li><li>其他操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加节点</span></span><br><span class="line">Node *u = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line">u-&gt;next = head;</span><br><span class="line">head = u;</span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line">head-&gt;next = head -&gt;next -&gt;next;</span><br><span class="line"><span class="comment">// 链表的遍历</span></span><br><span class="line"><span class="keyword">for</span>(Node *i =head;i;i=i-&gt;next)</span><br><span class="line">   cout &lt;&lt; i-&gt;val &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符用于动态分配内存，即在程序运行时从堆中分配一块指定大小的内存，并返回其地址。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol><li>求x的二进制第k位数字 <code>x &gt;&gt; k &amp; 1</code></li><li><code>lowbit(x)</code> = x &amp; -x，函数返回x的最后一位1<br><code>-x</code>和<code>~x+1</code>的二进制相同(补码和反码)</li></ol><h2 id="结构体中重载小于号"><a href="#结构体中重载小于号" class="headerlink" title="结构体中重载小于号"></a>结构体中重载小于号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">   <span class="type">int</span> value;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyStruct&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value &lt; other.value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在上面的代码中，我们定义了一个名为 operator&gt; 的函数，并将其作为成员函数添加到 MyStruct 结构体中。该函数接受一个类型为 const MyStruct&amp; 的参数，该参数表示将要比较的另一个结构体实例。此外，该函数还被声明为 const，以确保它不会修改当前结构体实例的状态。</span></span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li><p>声明常量：使用 const 关键字可以声明常量，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">// Pi 被声明为一个常量，其值不能被修改。</span></span><br></pre></td></tr></table></figure></li><li><p>参数传递：当你向一个函数传递参数时，使用 const 关键字可以防止函数对参数进行修改。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vec 被声明为 const 引用类型，这意味着函数 print 不会修改原始向量的内容。</span></span><br></pre></td></tr></table></figure></li><li><p>成员函数：使用 const 关键字可以将成员函数声明为不修改对象状态的函数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string name_;</span><br><span class="line">  <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GetName 和 GetAge 都是 const 成员函数。这些函数承诺不会修改对象的任何属性。</span></span><br></pre></td></tr></table></figure></li><li><p>指针和引用：使用 const 关键字可以防止指针或引用的值被修改。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="comment">// p 是一个指向 const int 类型的指针变量，这意味着你不能通过 p 修改它所指向的值。</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="include-lt-vector-gt"><a href="#include-lt-vector-gt" class="headerlink" title="#include &lt;vector&gt;"></a><code>#include &lt;vector&gt;</code></h2><ul><li><code>vector</code>是变长数组，支持随机访问，不支持在任意位置O(1)插入。为了保证效率，元素的增删一般应该在末尾进行。</li></ul><ol><li><p>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;      <span class="comment">// 相当于一个长度动态变化的int数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[<span class="number">233</span>]; <span class="comment">// 相当于第一维长233，第二维长度动态变化的int数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;;</span><br><span class="line">vector&lt;rec&gt; c;      <span class="comment">// 自定义的结构体类型也可以保存在vector中</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n, k)</span> <span class="comment">//初始化它的长度为n，所有元素值都是k</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>size/empty</code><br><code>size</code>函数返回<code>vector</code>的实际长度(包含的元素个数)。<br><code>empty</code>函数返回一个bool类型，表明<code>vector</code>是否为空。<br>二者的时间复杂度都是 O(1)。</p><ul><li>所有的STL容器都支持这两个方法，含义也相同</li></ul></li><li><p><code>clear</code><br><code>clear</code>函数把<code>vector</code>清空</p></li><li><p>迭代器<br>迭代器就像STL容器的“指针”，可以用星号*操作符解除引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个保存int的vector的迭代器声明方法为：</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p><code>vector</code>的迭代器是“随机访问迭代器”，可以把<code>vector</code>的迭代器与一个整数相加减，其行为和指针的移动类似。可以把<code>vector</code>的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。</p><ul><li>注意迭代器的类型不是int</li></ul></li><li><p><code>begin/end</code><br><code>begin</code>函数返回指向<code>vector</code>中第一个元素的迭代器。例如a是一个非空的<code>vector</code>，则*a.begin()与a[0]的作用相同。</p><p>所有的容器都可以视作一个“前闭后开”的结构，<code>end</code>函数返回<code>vector</code>的尾部，即第n个元素再往后的“边界”。</p><ul><li>*a.end()与a[n]都是越界访问，其中n = a.size()。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两份代码都遍历了vector&lt;int&gt; a，并输出它的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">   cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); it ++)</span><br><span class="line">   cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>front/back</code><br><code>front</code>函数返回<code>vector</code>的第一个元素，等价于<em>a.begin()和a[0]。<br><code>back</code>函数返回<code>vector</code>的最后一个元素，等价于</em>–a.end()和a[a.size() – 1]。</p></li><li><p><code>push_back()</code>和<code>pop_back()</code>(增删)<br><code>a.push_back(x)</code>把元素x插入到<code>vector</code>的尾部。<br><code>b.pop_back()</code>删除<code>vector</code>的最后一个元素。</p></li><li><p><code>insert/erase</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()+k,x) <span class="comment">// 将元素x插入位置k</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>()+k) <span class="comment">// 将位置k处的元素删除</span></span><br></pre></td></tr></table></figure></li><li><p><code>vector</code>比较<br>两个<code>vector</code>直接比较 <code>v1&gt;v2</code></p><ul><li>等同于<code>string</code>比大小，实际上是比第一个不同的元素的大小</li></ul></li></ol><ol start="10"><li>二维vector和vector数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">10</span>]; <span class="comment">// 10个vector组成的数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vs</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()) <span class="comment">// 二维vector，每个vector的元素和vector数量都可变长</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="include-lt-queue-gt"><a href="#include-lt-queue-gt" class="headerlink" title="#include &lt;queue&gt;"></a><code>#include &lt;queue&gt;</code></h2><ul><li>头文件<code>queue</code>主要包括循环队列<code>queue</code>和优先队列<code>priority_queue</code>两个容器。</li></ul><ol><li><p>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;; queue&lt;rec&gt; q;</span><br><span class="line"><span class="comment">//如果要定义一个结构体类型的优先队列，大根堆的结构体rec中必须定义小于号；小根堆的结构体rec中必须定义大于号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a,b;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Rec&amp; t) <span class="type">const</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> a &lt; t.a;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Rec&gt; q;</span><br><span class="line"><span class="comment">// 使用大根堆来表示最大优先级队列，即每次取出的元素都是当前队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 使用小根堆来表示最小优先级队列，即每次取出的元素都是当前队列中的最小值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure></li><li><p>循环队列<code>queue</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>)    <span class="comment">// 从队尾插入</span></span><br><span class="line">q.<span class="built_in">pop</span>()     <span class="comment">// 从队头弹出</span></span><br><span class="line">q.<span class="built_in">front</span>()   <span class="comment">// 返回队头元素</span></span><br><span class="line">q.<span class="built_in">back</span>()    <span class="comment">// 返回队尾元素</span></span><br><span class="line">q.<span class="built_in">empty</span>()</span><br><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure></li><li><p>优先队列<code>priority_queue</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>()    <span class="comment">// 把元素插入堆</span></span><br><span class="line">q.<span class="built_in">pop</span>()     <span class="comment">// 删除堆顶元素</span></span><br><span class="line">q.<span class="built_in">top</span>()     <span class="comment">// 查询堆顶元素（最大值）</span></span><br><span class="line">q.<span class="built_in">empty</span>()</span><br><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>priority_queue</code>并不支持随机访问和迭代器操作。如果需要遍历其中的元素，只能通过不断地从队首弹出元素来进行遍历。</li></ul><h2 id="include-lt-stack-gt"><a href="#include-lt-stack-gt" class="headerlink" title="#include &lt;stack&gt;"></a><code>#include &lt;stack&gt;</code></h2><p>头文件<code>stack</code>包含栈。声明和前面的容器类似。<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stk.<span class="built_in">push</span>(<span class="number">1</span>)    <span class="comment">// 向栈顶插入</span></span><br><span class="line">stk.<span class="built_in">pop</span>()     <span class="comment">// 删除栈顶元素</span></span><br><span class="line">stk.<span class="built_in">top</span>()     <span class="comment">// 返回栈顶元素</span></span><br><span class="line">stk.<span class="built_in">empty</span>()</span><br><span class="line">stk.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure></p><h2 id="include-lt-deque-gt"><a href="#include-lt-deque-gt" class="headerlink" title="#include &lt;deque&gt;"></a><code>#include &lt;deque&gt;</code></h2><p>双端队列<code>deque</code>是一个支持在两端高效插入或删除元素的连续线性存储空间。<br>它就像是<code>vector</code>和<code>queue</code>的结合。<br>   与<code>vector</code>相比，<code>deque</code>在头部增删元素仅需要O(1)的时间；<br>   与<code>queue</code>相比，<code>deque</code>像数组一样支持随机访问。</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d[]              <span class="comment">// 随机访问</span></span><br><span class="line">d.<span class="built_in">begin</span>()/d.<span class="built_in">end</span>()       <span class="comment">// 返回deque的头/尾迭代器</span></span><br><span class="line">d.<span class="built_in">front</span>()/d.<span class="built_in">back</span>()      <span class="comment">// 队头/队尾元素</span></span><br><span class="line">d.<span class="built_in">push_back</span>()       <span class="comment">// 从队尾入队</span></span><br><span class="line">d.<span class="built_in">push_front</span>()      <span class="comment">// 从队头入队</span></span><br><span class="line">d.<span class="built_in">pop_back</span>()        <span class="comment">// 从队尾出队</span></span><br><span class="line">d.<span class="built_in">pop_front</span>()       <span class="comment">// 从队头出队</span></span><br><span class="line">d.<span class="built_in">clear</span>()           <span class="comment">// 清空队列</span></span><br></pre></td></tr></table></figure><h2 id="include-lt-set-gt"><a href="#include-lt-set-gt" class="headerlink" title="#include &lt;set&gt;"></a><code>#include &lt;set&gt;</code></h2><p>头文件<code>set</code>主要包括<code>set</code>和<code>multiset</code>两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。<br><code>set</code>和<code>multiset</code>的内部实现是一棵红黑树，它们支持的函数基本相同。</p><ol><li><p>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;; set&lt;rec&gt; s;  <span class="comment">// 结构体rec中必须定义小于号</span></span><br><span class="line">multiset&lt;<span class="type">double</span>&gt; s;</span><br></pre></td></tr></table></figure></li><li><p><code>size/empty/clear</code><br>与<code>vector</code>类似</p></li><li><p>迭代器<br><code>set</code>和<code>multiset</code>的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号*解除引用，仅支持++和–两个与算术相关的操作。</p><p>设<code>it</code>是一个迭代器，例如<code>set&lt;int&gt;::iterator it;</code><br>若把<code>it ++</code>，则<code>it</code>会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在<code>it</code>下一名的元素。同理，若把<code>it --</code>，则<code>it</code>将会指向排在“上一个”的元素。</p></li><li><p><code>begin/end</code><br>返回集合的首、尾迭代器，时间复杂度均为 O(1)。</p><p><code>s.begin()</code>是指向集合中最小元素的迭代器。</p><p><code>s.end()</code>是指向集合中最大元素的下一个位置的迭代器。换言之，就像vector一样，是一个“前闭后开”的形式。因此<code>-- s.end()</code>是指向集合中最大元素的迭代器。</p></li><li><p><code>insert</code><br><code>s.insert(x)</code>把一个元素x插入到集合s中，时间复杂度为 <code>O(logn)</code>。</p><p>在<code>set</code>中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</p></li><li><p><code>find</code><br><code>s.find(x)</code>在集合<code>s</code>中查找等于<code>x</code>的元素，并返回指向该元素的迭代器。若不存在，则返回<code>s.end()</code>。时间复杂度为 <code>O(logn)</code>。</p></li><li><p><code>lower_bound/upper_bound</code><br>这两个函数的用法与<code>find</code>类似，但查找的条件略有不同，时间复杂度为<code>O(logn)</code>。</p><p><code>s.lower_bound(x)</code>查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。</p><p><code>s.upper_bound(x)</code>查找大于x的元素中最小的一个，并返回指向该元素的迭代器。</p></li><li><p><code>erase</code><br>设<code>it</code>是一个迭代器，<code>s.erase(it)</code>从s中删除迭代器it指向的元素，时间复杂度为 <code>O(logn)</code>。</p><p>设<code>x</code>是一个元素，<code>s.erase(x)</code>从<code>s</code>中删除所有等于<code>x</code>的元素，时间复杂度为 <code>O(k+logn)</code>，其中<code>k</code>是被删除的元素个数。</p></li><li><p><code>count</code><br><code>s.count(x)</code>返回集合<code>s</code>中等于<code>x</code>的元素个数，时间复杂度为 <code>O(k+logn)</code>，其中<code>k</code>为元素<code>x</code>的个数。</p></li></ol><h2 id="include-lt-map-gt"><a href="#include-lt-map-gt" class="headerlink" title="#include &lt;map&gt;"></a><code>#include &lt;map&gt;</code></h2><p><code>map</code>容器是一个键值对<code>key-value</code>的映射，其内部实现是一棵以<code>key</code>为关键码的红黑树。<code>Map</code>的<code>key</code>和<code>value</code>可以是任意类型，其中<code>key</code>必须定义小于号运算符。</p><ol><li><p>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; name;</span><br><span class="line">map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; hash;</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt; test;</span><br></pre></td></tr></table></figure></li><li><p><code>size/empty/clear/begin/end</code><br>均与<code>set</code>类似。</p></li><li><p><code>insert/erase</code><br>与<code>set</code>类似，但其参数均是<code>pair&lt;key_type, value_type&gt;</code>。</p></li><li><p><code>find</code><br><code>h.find(x)</code>在变量名为<code>h</code>的<code>map</code>中查找<code>key</code>为<code>x</code>的二元组。</p></li><li><p>[]操作符<br><code>h[key]</code>返回<code>key</code>映射的<code>value</code>的引用，时间复杂度为<code>O(logn)</code>。</p><p><code>[]</code>操作符是<code>map</code>最吸引人的地方。我们可以很方便地通过<code>h[key]</code>来得到<code>key</code>对应的<code>value</code>，还可以对<code>h[key]</code>进行赋值操作，改变<code>key</code>对应的<code>value</code>。</p></li></ol><h2 id="‘-include-‘-哈希表-无序集合"><a href="#‘-include-‘-哈希表-无序集合" class="headerlink" title="‘#include ‘ 哈希表(无序集合)"></a>‘#include <unordered_set>‘ 哈希表(无序集合)</h2><p><code>unordered_set</code>提供了一种存储唯一元素的方式，即不允许重复。<br>   与<code>set</code>不同的是，<code>unordered_set</code>没有按照特定顺序排序，并且它们的存储位置是根据哈希函数计算得出的。相反，它使用哈希表来实现元素的快速查找，插入和删除。<br>   因此，<code>unordered_set</code>常常比<code>set</code>更快，特别是当涉及到大量数据时。由于哈希表的使用，<code>unordered_set</code>提供快速的查找、插入和删除操作，但这也意味着在迭代容器时，元素的顺序可能随机，不能保证与插入的顺序相同。</p><ul><li>当使用哈希表时，插入、删除和查找元素的平均时间复杂度为O(1)。这是因为哈希表使用哈希函数将键映射到哈希桶中的索引位置，从而使得哈希表可以在常数时间内访问每个元素。</li></ul><p><code>unordered_multiset</code>与<code>unordered_set</code>类似，但允许存储多个相同的元素。它也使用哈希表来实现快速查找、插入和删除，而且不保证元素的顺序与插入的顺序相同。与<code>multiset</code>不同的是，<code>unordered_multiset</code>提供了更快的查找操作，但在迭代容器时，元素的顺序可能随机。</p><p>函数：</p><ol><li><code>insert()</code>: 向集合中插入元素。</li><li><code>erase()</code>: 从集合中删除指定元素。</li><li><code>clear()</code>: 删除集合中的所有元素。</li><li><code>size()</code>: 返回集合中元素的数量。</li><li><code>empty()</code>: 判断集合是否为空。</li><li><code>find()</code>: 在集合中查找指定元素的位置，如果不存在则返回end()迭代器。</li><li><code>count()</code>: 返回集合中某个键出现的次数，因为<code>unordered_set</code>不允许重复元素，所以返回值只能是0或1。</li></ol><ul><li><p>注：由于哈希表的使用，<code>unordered_set</code>和<code>unordered_multiset</code>提供了常数时间的平均性能，但是最坏情况下的性能会比较差。同时，由于哈希表的使用，<code>unordered_set</code>和<code>unordered_multiset</code>并不支持有序性相关的操作，例如<code>lower_bound</code>和<code>upper_bound</code>。</p></li><li><p>对比：<code>set</code>和<code>unordered_set</code>都是<code>C++ STL</code>中的关联容器，它们的主要区别在于底层数据结构不同。</p><p> <code>set</code>使用红黑树实现，因此元素按照键值排序。这种有序性质使得set能够进行有序的遍历、查找和范围查询，但插入、删除操作的时间复杂度较高，为O(log n)。<br> <code>unordered_set</code>使用哈希表实现，因此元素没有按照键值排序。哈希表的优势在于插入、删除、查找元素的平均时间复杂度为O(1)，但是由于哈希表中元素的位置是无序的，所以<code>unordered_set</code>不支持有序的遍历和范围查询。<br>如果需要对元素进行有序的遍历、查找和范围查询，应该使用<code>set</code>；如果对时间复杂度有更高的要求，而不关心元素的顺序，可以使用<code>unordered_set</code>。</p></li></ul><h2 id="‘-include-‘"><a href="#‘-include-‘" class="headerlink" title="‘#include ‘"></a>‘#include <unordered_map>‘</h2><p><code>unordered_map</code>提供了一种关联数组的实现方式，即将键和值存储在一起，并且保证键的唯一性。与<code>map</code>不同的是，<code>unordered_map</code>没有按照特定顺序排序。相反，它使用哈希表来实现键的快速查找、插入和删除，因此，<code>unordered_map</code>常常比<code>map</code>更快，特别是当涉及到大量数据时。</p><ul><li>注：由于哈希表的使用，<code>unordered_map</code>提供快速的查找、插入和删除操作，但这也意味着在迭代容器时，元素的顺序可能随机，不能保证与插入的顺序相同。另外，由于哈希表的使用，<code>unordered_map</code>提供了常数时间的平均性能，但是最坏情况下的性能会比较差。</li></ul><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>   两点之间的曼哈顿距离：<code>|x1-x2|+|y1-y2|</code><br>   用于找规律输出矩阵(点与点距离/点与面距离) </p><h2 id="模拟数组"><a href="#模拟数组" class="headerlink" title="模拟数组"></a>模拟数组</h2><p>   输出矩阵时，可以不直接定义数组，而是在二重循环中定义变量来模拟数组的运行<br>   方便设置初始值</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>   建立<code>dx[]</code>和<code>dy[]</code>的每一个数对(dx[i],dy[i])来表示每次运动的位置变换</p><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><ol><li>第一类双指针算法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> j=i;</span><br><span class="line">   <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>() &amp;&amp; s[j]=s[i]) j++;</span><br><span class="line">   i=j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>   在使用函数时使用全局变量，函数类型使用void。优点是此时方便使用函数的多个结果。</p><h2 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h2><p>用来处理头结点可能被删除的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node *dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">dummy-&gt;next = head;</span><br></pre></td></tr></table></figure><h1 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h1><ol><li><p>swap(A,B)<br>交换A和B的值<br>头文件：iostream</p></li><li><p>abs(A)<br>对A取绝对值<br>所在库：cmath</p></li><li><p>sqrt(A)<br>对A开方</p></li><li><p>fabs(A)<br>对浮点数A取绝对值</p></li></ol><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ol><li><p>s.empty()<br>判断string是否为空</p></li><li><p>s.size()<br>返回string的大小</p></li><li><p>s.substr(i,len)/s.substr(i)<br>返回从s[i]开始长度为len的子串/返回从s[i]开始长度的剩余子串</p></li><li><p>s.back()<br>返回string的最后一个字符</p></li><li><p>s.pop_back()<br>删除string的最后一个字符</p></li></ol><h2 id="sstream-字符串流"><a href="#sstream-字符串流" class="headerlink" title="sstream(字符串流)"></a>sstream(字符串流)</h2><ol><li>stringstream类<br>用于分离字符串中使用分隔符分开的各个部分(类型不限)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="function">stringstream <span class="title">ssin</span><span class="params">(s)</span></span>; <span class="comment">//使用stringstream类从一个字符串中提取值，这个字符串中每个值之间使用分隔符分开（如空格、逗号等）</span></span><br><span class="line">string str;</span><br><span class="line"> <span class="keyword">while</span> (ssin &gt;&gt; str) <span class="comment">//stringstream对象ssin用于存储字符串，而while循环则用于从stringstream中提取值并将其存储在变量str中(类似cin)</span></span><br><span class="line"> &#123;</span><br><span class="line">   cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h2><ol><li>pow(a,b)  </li></ol><h2 id="algorithm-重点"><a href="#algorithm-重点" class="headerlink" title="algorithm(重点)"></a>algorithm(重点)</h2><ol><li><p>max(a,b) / min(a,b)<br>求a和b之间的最大值和最小值</p></li><li><p>reverse 翻转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻转一个vector：</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//翻转一个数组，元素存放在下标0 ~ n-1：</span></span><br><span class="line"><span class="built_in">reverse</span>(a, a + n);</span><br></pre></td></tr></table></figure></li><li><p>unique 去重<br>返回去重（只去掉相邻的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。重复的元素放置在后面<br>该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把一个vector去重：</span></span><br><span class="line"><span class="type">int</span> m = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) – a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//把一个数组去重，元素存放在下标1 ~ n：</span></span><br><span class="line"><span class="type">int</span> m = <span class="built_in">unique</span>(a, a + n) – (a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>random_shuffle 随机打乱<br>用法与reverse相同</p></li><li><p>sort<br>对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一个int数组从大到小排序，传入比较函数：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">   string name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comparePersons</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> p1.age &lt; p2.age; <span class="comment">// 按照年龄升序排列</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), comparePersons);<span class="comment">// sort中需要加入比较函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把自定义的结构体vector排序，重载“小于号”运算符：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">   string name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; other) <span class="type">const</span> </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> age &lt; other.age; <span class="comment">// 按照年龄升序排列</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p>lower_bound/upper_bound 二分<br><code>lower_bound</code>的第三个参数传入一个元素<code>x</code>，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于<code>x</code>的元素的位置的迭代器（指针）。<br><code>upper_bound</code>的用法和<code>lower_bound</code>大致相同，唯一的区别是查找第一个大于<code>x</code>的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在有序int数组（元素存放在下标1 ~ n）中查找大于等于x的最小整数的下标：</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, x) - a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在有序vector&lt;int&gt;中查找小于等于x的最大整数（假设一定存在）：</span></span><br><span class="line"><span class="type">int</span> y = *--<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure></li></ol><h2 id="cstring"><a href="#cstring" class="headerlink" title="cstring"></a>cstring</h2><p>用于数组和字符数组(C风格字符串)</p><ol><li><p>memset(a,0,sizeof(a))<br>将数组中每一个元素的每一位上赋值为0<br>注：由于是给每一位上赋值，所以只有0和-1赋值后每个元素都是0和-1</p></li><li><p>memcpy(b,a,sizeof(a))<br>将数组a的元素值赋值给数组b</p></li><li><p>strlen(str)<br>求字符串的长度</p></li><li><p>strcmp(a, b)<br>比较两个字符串的大小，a &lt; b返回-1，a == b返回0，a &gt; b返回1。这里的比较方式是字典序！</p></li><li><p>strcpy(a, b)<br>将字符串b复制给从a开始的字符数组。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客说明</title>
      <link href="/2023/04/16/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/04/16/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="文章更新"><a href="#文章更新" class="headerlink" title="文章更新"></a>文章更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy // Git BASH终端</span><br><span class="line">hexo clean; hexo generate; hexo deploy // VSCODE终端</span><br></pre></td></tr></table></figure><ol><li>hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令</li><li>hexo generate：生成静态文章，可以用hexo g缩写</li><li>hexo deploy：部署文章，可以用hexo d缩写</li></ol><h2 id="图片更新"><a href="#图片更新" class="headerlink" title="图片更新"></a>图片更新</h2><p>图片位置：<a href="https://picture.eureka517.cn/img/dm1.webp">https://picture.eureka517.cn/img/dm1.webp</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在E:\Hexo-Blog\picture_bed\blog_picture目录下Git Bush将更改提交</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;更新图片&quot;</span><br><span class="line"># 推送至github仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h1 id="文章部分"><a href="#文章部分" class="headerlink" title="文章部分"></a>文章部分</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是 markdown 文件最上方以—分隔的区域，用于指定个别档案的变数。</p><ul><li>Page Front-matter 用于页面配置</li><li>Post Front-matter 用于文章页配置</li></ul><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter:"></a>Page Front-matter:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标签、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h3 id="Post-Front-matter-写文章看这里-："><a href="#Post-Front-matter-写文章看这里-：" class="headerlink" title="Post Front-matter(写文章看这里)："></a>Post Front-matter(写文章看这里)：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="md文件规范"><a href="#md文件规范" class="headerlink" title="md文件规范"></a>md文件规范</h2><ol><li>md文件名<br> md文件的名字不能有特殊字符，否则文章会存在404错误</li></ol>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
